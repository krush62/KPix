name: Flutter • Manual Build (Android + Windows + Linux)

on:
  workflow_dispatch:
    inputs:
      build_android_apk:
        description: "Build Android APK"
        type: boolean
        default: true
      build_android_aab:
        description: "Build Android AAB"
        type: boolean
        default: true
      build_windows:
        description: "Build Windows"
        type: boolean
        default: true
      build_linux_package:
        description: "Build Linux Package"
        type: boolean
        default: true
      build_linux_appimage:
        description: "Build Linux AppImage"
        type: boolean
        default: true

permissions:
  contents: read

env:
  FLUTTER_VERSION: "3.38.1"
  FLUTTER_CHANNEL: "stable"

jobs:
  setup:
    name: Setup Version & Timestamp
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.extract_version.outputs.version }}
      timestamp: ${{ steps.build_time.outputs.timestamp }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Extract version from pubspec.yaml
        id: extract_version
        run: |
          VERSION=$(grep ^version: pubspec.yaml | awk '{print $2}' | cut -d+ -f1)
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Generate build timestamp
        id: build_time
        run: |
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          echo "timestamp=$TIMESTAMP" >> $GITHUB_OUTPUT

  android:
    if: ${{ inputs.build_android_apk || inputs.build_android_aab }}
    needs: setup
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - buildType: apk
            enabled: ${{ inputs.build_android_apk }}
          - buildType: aab
            enabled: ${{ inputs.build_android_aab }}
    env:
      VERSION: ${{ needs.setup.outputs.version }}
      TIMESTAMP: ${{ needs.setup.outputs.timestamp }}
    steps:
      - name: Skip disabled build type
        if: ${{ !matrix.enabled }}
        run: echo "Skipping disabled build type."

      - name: Checkout
        if: ${{ matrix.enabled }}
        uses: actions/checkout@v4

      - name: Setup Java
        if: ${{ matrix.enabled }}
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"

      - name: Setup Flutter
        if: ${{ matrix.enabled }}
        uses: subosito/flutter-action@v2
        with:
          flutter-version: ${{ env.FLUTTER_VERSION }}
          channel: ${{ env.FLUTTER_CHANNEL }}
          cache: true

      - name: Cache Pub
        if: ${{ matrix.enabled }}
        uses: actions/cache@v4
        with:
          path: ~/.pub-cache
          key: ${{ runner.os }}-pub-${{ hashFiles('pubspec.lock') }}
          restore-keys: |
            ${{ runner.os }}-pub-


      - name: Cache Gradle
        if: ${{ matrix.enabled }}
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      - name: Flutter • Dependencies
        if: ${{ matrix.enabled }}
        run: flutter pub get

      - name: Android • Setup signing
        if: ${{ matrix.enabled }}
        shell: bash

        run: |
          # Write keystore from Base64
          echo "${ANDROID_KEYSTORE_BASE64}" | base64 -d > android/app/keystore.jks
          
          # Create key.properties consumed by build.gradle
          cat > android/key.properties <<EOF
          storePassword=${{ secrets.ANDROID_KEYSTORE_PASSWORD }}
          keyPassword=${{ secrets.ANDROID_KEY_PASSWORD }}
          keyAlias=${{ secrets.ANDROID_KEY_ALIAS }}
          storeFile=keystore.jks
          EOF
        env:
          ANDROID_KEYSTORE_BASE64: ${{ secrets.ANDROID_KEYSTORE_BASE64 }}

      - name: Android • Build AAB & APK
        if: ${{ matrix.enabled }}
        run: |
          if [ "${{ matrix.buildType }}" = "apk" ]; then
            flutter build apk --release
          else
            flutter build appbundle --release
          fi

      - name: Copy artifact to top-level
        if: ${{ matrix.enabled }}
        run: |
          if [ "${{ matrix.buildType }}" = "apk" ]; then
            FILE=$(find build/app/outputs/flutter-apk -name "*release*.apk" | head -n 1)
            EXT=apk
          else
            FILE=$(find build/app/outputs/bundle -name "*.aab" | head -n 1)
            EXT=aab
          fi

          TOPLEVEL_FILE="kpix-android-${{ matrix.buildType }}-v${{ env.VERSION }}-${{ env.TIMESTAMP }}.$EXT"
          cp "$FILE" "$TOPLEVEL_FILE"
          echo "ARTIFACT_FILE=$TOPLEVEL_FILE" >> $GITHUB_ENV

      - name: Upload artifact
        if: ${{ matrix.enabled }}
        uses: actions/upload-artifact@v4
        with:
          name: kpix-android-${{ matrix.buildType }}-v${{ env.VERSION }}-${{ env.TIMESTAMP }}
          path: ${{ env.ARTIFACT_FILE }}




  desktop:
    if: ${{ inputs.build_windows || inputs.build_linux }}
    needs: setup
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            platform: linux
            enabled: ${{ inputs.build_linux_package || inputs.build_linux_appimage }}
          - os: windows-latest
            platform: windows
            enabled: ${{ inputs.build_windows }}
    runs-on: ${{ matrix.os }}
    env:
      VERSION: ${{ needs.setup.outputs.version }}
      TIMESTAMP: ${{ needs.setup.outputs.timestamp }}
    steps:
      - name: Skip if this platform disabled
        if: ${{ !matrix.enabled }}
        run: echo "Skipping disabled platform."

      - name: Checkout
        if: ${{ matrix.enabled }}
        uses: actions/checkout@v4

      - name: Set up Flutter
        if: ${{ matrix.enabled }}
        uses: subosito/flutter-action@v2
        with:
          flutter-version: ${{ env.FLUTTER_VERSION }}
          channel: ${{ env.FLUTTER_CHANNEL }}
          cache: true

      - name: Flutter • Dependencies
        if: ${{ matrix.enabled }}
        run: flutter pub get

      # Linux-specific deps
      - name: Install Linux build deps
        if: ${{ matrix.enabled && matrix.platform == 'linux' }}
        run: |
          sudo apt-get update
          sudo apt-get install -y ninja-build libgtk-3-dev

      # Build Linux
      - name: Build • Linux
        if: ${{ matrix.enabled && matrix.platform == 'linux' }}
        run: |          
          flutter build linux --release

      - name: Package Linux Release
        if: ${{ matrix.enabled && matrix.platform == 'linux' && inputs.build_linux_package }}
        run: |
          RELEASE_DIR="build/linux/x64/release/bundle"
          ARCHIVE_NAME="kpix-linux-v${{ env.VERSION }}-${{ env.TIMESTAMP }}.tar.gz"

          if [ ! -d "$RELEASE_DIR" ]; then
            echo "Release directory $RELEASE_DIR not found!"
            exit 1
          fi

          # Create tar.gz containing the contents of the bundle folder
          tar -czf "$ARCHIVE_NAME" -C "$RELEASE_DIR" .

          echo "Created archive: $ARCHIVE_NAME"

      - name: Upload Linux Artifact
        if: ${{ matrix.enabled && matrix.platform == 'linux' && inputs.build_linux_package }}
        uses: actions/upload-artifact@v4
        with:
          name: linux-v${{ env.VERSION }}-${{ env.TIMESTAMP }}
          path: kpix-linux-v${{ env.VERSION }}-${{ env.TIMESTAMP }}.tar.gz



      - name: Create Linux AppImage
        if: ${{ matrix.enabled && matrix.platform == 'linux' && inputs.build_linux_appimage }}
        env:
          VERSION: ${{ env.VERSION }}
        run: |
          set -e

          APPIMAGE_TOOL_URL="https://github.com/AppImage/appimagetool/releases/download/continuous"
          APPIMAGE_EXEC="appimagetool-x86_64.AppImage"
          BUNDLE_DIR="build/linux/x64/release/bundle"
          OUTPUT_DIR="release_tools/LinuxAppImage"
          APPDIR_PATH="KPix.AppDir"
          ICON_PATH="imgs/kpix_icon.png"
          APPRUN_FILE="$OUTPUT_DIR/$APPDIR_PATH/AppRun"
          DESKTOP_FILE="$OUTPUT_DIR/$APPDIR_PATH/KPix.desktop"
          OUTPUT_FILE_NAME="KPix-${VERSION}-x86_64.AppImage"

          if [ ! -d "$BUNDLE_DIR" ]; then
            echo "Error: Bundle directory not found at $BUNDLE_DIR"
            exit 1
          fi

          echo "Creating output directory"
          mkdir -p "$OUTPUT_DIR"

          echo "Downloading appimagetool"
          wget -q "$APPIMAGE_TOOL_URL/$APPIMAGE_EXEC" -O "$OUTPUT_DIR/$APPIMAGE_EXEC"
          chmod +x "$OUTPUT_DIR/$APPIMAGE_EXEC"

          echo "Copying bundle into AppDir"
          rm -rf "$OUTPUT_DIR/$APPDIR_PATH"
          mkdir -p "$OUTPUT_DIR/$APPDIR_PATH"
          cp -r "$BUNDLE_DIR/"* "$OUTPUT_DIR/$APPDIR_PATH/"

          echo "Copying icon"
          cp "$ICON_PATH" "$OUTPUT_DIR/$APPDIR_PATH/kpix.png"

          echo "Creating AppRun"
          cat > "$APPRUN_FILE" << 'EOF'
          #!/bin/sh
          cd "$(dirname "$0")"
          exec ./kpix
          EOF
          chmod +x "$APPRUN_FILE"
          
          echo "Creating .desktop file"
          cat > "$DESKTOP_FILE" << EOF
          [Desktop Entry]
          Version=$VERSION
          Type=Application
          Terminal=false
          Name=KPix
          Comment=KPix is a pixel art editor for still images and animations with a focus on generative color ramps and shading.
          Exec=kpix %u
          Icon=kpix
          Categories=Graphics;
          Keywords=pixelart;
          PrefersNonDefaultGPU=true
          SingleMainWindow=true
          EOF
          
          echo "Creating AppImage package"
          "$OUTPUT_DIR/$APPIMAGE_EXEC" "$OUTPUT_DIR/$APPDIR_PATH" "$OUTPUT_DIR/$OUTPUT_FILE_NAME"
          
          echo "Cleaning up temporary files"
          rm -rf "$OUTPUT_DIR/$APPDIR_PATH"
          rm -f "$OUTPUT_DIR/$APPIMAGE_EXEC" "$OUTPUT_DIR/$APPIMAGE_EXEC".[0-9]*
          
          echo "AppImage created: $OUTPUT_DIR/$OUTPUT_FILE_NAME"

      - name: Upload Linux AppImage
        if: ${{ matrix.enabled && matrix.platform == 'linux' && inputs.build_linux_appimage }}
        uses: actions/upload-artifact@v4
        with:
          name: kpix-linux-appimage-v${{ env.VERSION }}
          path: release_tools/LinuxAppImage/KPix-${{ env.VERSION }}-x86_64.AppImage

      # Build Windows
      - name: Build • Windows
        if: ${{ matrix.enabled && matrix.platform == 'windows' }}
        shell: pwsh
        run: |
          Write-Host "Running: flutter build windows --release"
          flutter build windows --release

      # Package Windows Release including data folder and VC++ DLLs
      - name: Package Windows Release
        if: ${{ matrix.enabled && matrix.platform == 'windows' }}
        shell: pwsh
        env:
          VERSION: ${{ needs.setup.outputs.version }}
          TIMESTAMP: ${{ needs.setup.outputs.timestamp }}
        run: |
          $releaseDir = "build/windows/x64/runner/Release"
          $zipFile = "kpix-windows-x64-v$env:VERSION-$env:TIMESTAMP.zip"
          
          if (-Not (Test-Path $releaseDir)) {
            Write-Host "Release folder does not exist. Skipping packaging."
            exit 0
          }
        
          $exeDllFiles = Get-ChildItem -Path $releaseDir -File | Where-Object {
            $_.Extension -in ".exe", ".dll"
          } | ForEach-Object { $_.FullName }
        
          $dataFolder = Join-Path $releaseDir "data"
          $pathsToZip = @($exeDllFiles)  # start array
          if (Test-Path $dataFolder) {
            $pathsToZip += $dataFolder
          } else {
            Write-Host "Warning: data folder not found!"
          }
        
          $vcDlls = @(
            "C:\Windows\System32\msvcp140.dll",
            "C:\Windows\System32\msvcp140_1.dll",
            "C:\Windows\System32\msvcp140_2.dll",
            "C:\Windows\System32\vcruntime140.dll",
            "C:\Windows\System32\vcruntime140_1.dll"
          )
          
          foreach ($dll in $vcDlls) {
            if (Test-Path $dll) {
              Copy-Item $dll -Destination $releaseDir -Force
              $pathsToZip += Join-Path $releaseDir (Split-Path $dll -Leaf)
            } else {
              Write-Host "Warning: $dll not found on runner!"
            }
          }
        
          if ($pathsToZip.Count -gt 0) {
            Remove-Item -Force $zipFile -ErrorAction SilentlyContinue
            Compress-Archive -Path $pathsToZip -DestinationPath $zipFile
            Write-Host "Windows artifact created: $zipFile"
          } else {
            Write-Host "No files to zip."
          }



        # Upload Windows Artifact
      - name: Upload Windows Artifact
        if: ${{ matrix.enabled && matrix.platform == 'windows' }}
        uses: actions/upload-artifact@v4
        with:
          name: windows-package-v${{ env.VERSION }}-${{ env.TIMESTAMP }}
          path: kpix-windows-x64-v${{ env.VERSION }}-${{ env.TIMESTAMP }}.zip
          if-no-files-found: ignore

      # Install Inno Setup
      - name: Install Inno Setup
        if: ${{ matrix.enabled && matrix.platform == 'windows' }}
        shell: pwsh
        run: |
          Set-ExecutionPolicy Bypass -Scope Process -Force
          choco install innosetup -y

      # Build Windows Installer
      - name: Build Windows Installer
        if: ${{ matrix.enabled && matrix.platform == 'windows' }}
        shell: pwsh
        env:
          VERSION: ${{ needs.setup.outputs.version }}
          TIMESTAMP: ${{ needs.setup.outputs.timestamp }}
        run: |
          $issFile = "release_tools/windows_installer_build.iss"
          $outputDir = "build/windows_installer"
          New-Item -ItemType Directory -Force -Path $outputDir
          
          $outputFile = "kpix-windows-installer-v$env:VERSION-$env:TIMESTAMP"
          ISCC.exe /O"$outputDir" /F"$outputFile" $issFile

      # Upload Windows Installer
      - name: Upload Windows Installer
        if: ${{ matrix.enabled && matrix.platform == 'windows' }}
        uses: actions/upload-artifact@v4
        with:
          name: windows-installer-v${{ env.VERSION }}-${{ env.TIMESTAMP }}
          path: build/windows_installer/*.exe
          if-no-files-found: ignore